---
title: "Study 1 - Direct Replication of Wish et al., 1976"
author: "Haroon Popal"
date: "12/18/2020"
output: 
  html_document:
    toc: true
    toc_float: 
      collapsed: false
    df_print: paged
    css: !expr here::here("style_srk_behavioral.css")
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```


```{r, results=FALSE}
if(!require(FactoMineR)) install.packages("FactoMineR"); require(FactoMineR)
if(!require(factoextra)) install.packages("factoextra"); require(factoextra)
library(psych)
library(ggplot2)
if(!require(reshape)) install.packages("reshape"); require(reshape)
library(cowplot)
library(stringr)
if(!require(plotly)) install.packages("plotly"); require(plotly)


setwd("C:/Users/Administrator/Google_Drive/olson_lab/projects/relationship_knowledge/results/wish_replication/")
#setwd("~/Google_Drive/olson_lab/projects/relationship_knowledge/results/wish_replication/")
getwd()
```


# Principal Component Analysis
Principal component analysis (PCA) will be used as a dimensionality technique to find the over-arching dimensions that represent knowledge about social relationships. In this study, we will replicate a previous study done nearly 40 years about (Wish et al.,1976).

## Import data
This dataset was collected from a survey hosted on mturk. The survey data was cleaned with a separate python script. A matrix was created for the average rating of social relationships on dimensions that are thought to characterize these relationships. The relationships and dimensions used in this analysis are the same ones from Wish et al., 1976. 
```{r}
dim_rel_scaled = read.csv('dim_rel_scaled.csv', row.names=1)
rownames(dim_rel_scaled) <- str_replace(rownames(dim_rel_scaled), "â\200“", "-")
```
!['Wish relationships rated on Wish dimensions'](dim_rel_heatmap.png)

## Quantitatively selecting the number of components
PCA will output the same number of components as there are dimension inputs. As the components are ranked by how much variance they explain, we can exclude some components which do not add much additional information.

### Parallel Analysis
We will use parallel analysis to indicate what the optimal number of components to include would be.
```{r}
png(filename="pca_results/parallel_analysis.png")
fa.parallel(dim_rel_scaled,fa="pc")
dev.off()
fa.parallel(dim_rel_scaled,fa="pc")
```
Parallel analysis indicates that having only 2 components would be optimal. But to better match the literature, and to be consistent with possible future analyses, we will include 4 components.

## Screeplot
PCA with no rotation is done here to visualize the amount of variance accounted for by each component. 
```{r}

res.pca_nor <- PCA(dim_rel_scaled, ncp=4, graph=FALSE)

write.csv(res.pca_nor$var$coord, file = 'pca_results/pca_loadings_nrotate.csv')
write.csv(res.pca_nor$ind$coord, file = 'pca_results/pca_relationships_nrotate.csv')

# Create screeplot
png(filename="pca_results/scree_plot.png")
fviz_screeplot(res.pca_nor) + ggtitle("") +
theme(text = element_text(size = 20))
dev.off()
fviz_screeplot(res.pca_nor) + ggtitle("") +
theme(text = element_text(size = 20))
```


# PCA with varimax rotation
Rotations are used in principal component analyses to be able to better interpret the data. There are two main types of rotations, varimax and oblimin. Here, we will use varimax rotation, as it will maximize the component loadings so that dimensions are more strongly loaded onto a single component, rather than across components. Because of this, our resulting components may correlate with each other. Oblimin rotation results in components that are uncorrelated to each other. 
```{r}
pv <- principal(dim_rel_scaled, 4, rotate="varimax")

pv$loadings <- pv$loadings[ order(row.names(pv$loadings)), ][ , order(colnames(pv$loadings)) ]
write.csv(pv$loadings, file = 'pca_results/pca_loadings_varimax.csv')
write.csv(pv$scores, file = 'pca_results/pca_relationships_varimax.csv')

print(paste0("First four components account for ", 
             round(pv$Vaccounted[3,4], digits = 4)*100,
            "% of the variance"))
```

## Component Loadings
```{r}
loadings_var <- cbind(melt(as.matrix(as.data.frame(pv$loadings[,1:4]))), "Varimax")
colnames(loadings_var)[4] <- 'Rotation'

ggplot(data = loadings_var, aes(x = X2, y = X1)) +
    geom_tile(aes(fill = value)) + 
    scale_fill_distiller(palette="RdBu", limits=c(-1,1)) +
    ggtitle("Varimax PCA Loadings") +
    ylab("Wish Dimensions") +
    theme_minimal() +
    theme(text = element_text(size = 12), axis.title.x=element_blank()) 
ggsave('pca_results/pca_loadings_varimax.png')
```

```{r}
comp1_loadings <- loadings_var[loadings_var$X2=='RC1',]
print(cat('Component 1 highest positive loadings:',
            gsub('\\.', ' ', toString(comp1_loadings[comp1_loadings$value > 0.5,]$X1))))
print(cat('\nComponent 1 highest negative loadings:',
            gsub('\\.', ' ', toString(comp1_loadings[comp1_loadings$value < -0.5,]$X1))))

comp2_loadings <- loadings_var[loadings_var$X2=='RC2',]
print(cat('\nComponent 2 highest positive loadings:',
            gsub('\\.', ' ', toString(comp2_loadings[comp2_loadings$value > 0.5,]$X1))))
print(cat('\nComponent 2 highest negative loadings:',
            gsub('\\.', ' ', toString(comp2_loadings[comp2_loadings$value < -0.5,]$X1))))

comp3_loadings <- loadings_var[loadings_var$X2=='RC3',]
print(cat('\nComponent 3 highest positive loadings:',
            gsub('\\.', ' ', toString(comp3_loadings[comp3_loadings$value > 0.5,]$X1))))
print(cat('\nComponent 3 highest negative loadings:',
            gsub('\\.', ' ', toString(comp3_loadings[comp3_loadings$value < -0.5,]$X1))))

comp4_loadings <- loadings_var[loadings_var$X2=='RC4',]
print(cat('\nComponent 4 highest positive loadings:',
            gsub('\\.', ' ', toString(comp4_loadings[comp4_loadings$value > 0.5,]$X1))))
print(cat('\nComponent 4 highest negative loadings:',
            gsub('\\.', ' ', toString(comp4_loadings[comp4_loadings$value < -0.5,]$X1))))

```

### Comparison to Wish Dimensions
Wish et al., 1976 - Table 2
```{r}
library(dplyr)

# Import dimension loadings from Wish et al., 1976
wish_dim1 = c(.89, .87, .87, .87, .85, .84, .76, .75, .73, .02, .11, 
             .12, .10, -.03, .12, .16, -.03, .32, -.13, .40, .42, .47, 
             .55, .59, .20)
wish_dim2 = c(.04, .04, .04, .06, .04, .05, .04, .22, .07, .96, .91, 
             .07, .10, .02, .12, .06, .06, .05, -.01, .63, .02, .04,
             .10, .14, -.01)
wish_dim3 = c(-.01, .04, .08, .10, .16, .03, .07, .07, .00, .02, .09, 
             .81, .75, .73, .64, .53, -.08, .14, .22, .00, .64, .36, 
             .25, .00, .53)
wish_dim4 = c(-.10, -.06, .12, .01, -.06, .04, .24, .13, .29, .03, .02,
             -.06, .18, .22, .15, .01, .95, .70, .70, .27, .08, .42, 
             .40, .43, .43)
wish_loadings <- data.frame(wish_dim1, wish_dim2, wish_dim3, wish_dim4)
wish_loadings$dims <- c('Harmonious.vs.Clashing', 'Cooperative.vs.Competitive', 'Friendly.vs.Hostile',
  'Compatible.vs.incompatible.goals.and.desires', 'Productive.vs.Destructive',
  'Easy.vs.Difficult.to.resolve.conflicts.with.each.other','Altruistic.vs.Selfish',
  'Fair.vs.Unfair', 'Relaxed.vs.Tense', 'Equal.vs.Unequal','Similar.vs.Different.roles.and.behavior',
  'Active.vs.Inactive','Intense.vs.Superficial.interaction.with.each.other',
  'Intense.vs.Superficial.feelings.toward.each.other','Interesting.vs.Dull',
  'Important.vs.Unimportant.to.society','Pleasure.vs.Work.oriented','Informal.vs.Formal',
  'Emotional.vs.Intellectual','Democratic.vs.Autocratic','Important.vs.Unimportant.to.individuals.involved',
  'Emotionally.close.vs.distant','Sincere.vs.Insincere','Flexible.vs.Rigid',
  'Difficult.vs.Easy.to.break.off.contact.with.each.other')

# Rearrange rows so that they match the PCA loadings dataframe
wish_loadings <- wish_loadings %>%
  mutate(dims =  factor(dims, levels = rownames(pv$loadings[,1:4]))) %>%
  arrange(dims)

rownames(wish_loadings) <- wish_loadings$dims
wish_loadings <- wish_loadings[,1:4]
#wish_loadings
write.csv(wish_loadings, file = 'pca_results/wish_loadings.csv')
```

```{r}
# Merge together PCA and wish loadings dataframes
loadings_all_temp <- merge(pv$loadings[,1:4], wish_loadings, by="row.names")
loadings_all <- loadings_all_temp[,-1]  # Reset the index to be relationships
rownames(loadings_all) <- loadings_all_temp[,1]
colnames(loadings_all) <- c('RC1','RC2','RC3','RC4',
                              'Dim1','Dim2','Dim3','Dim4')

# Calculate correlation matrix of all dimensions across all methods
loadings_all.cor = cor(loadings_all, method=c("spearman"))

# Create heatmap plot 
loadings_all.cor_melt <- melt(loadings_all.cor)

limit <- max(abs(loadings_all.cor_melt$value)) * c(-1, 1)
ggplot(data = loadings_all.cor_melt, aes(x = X2, y = X1)) +
    geom_tile(aes(fill = value)) + 
    scale_fill_distiller(palette="RdBu", limit=limit) + 
    ggtitle('Principal Component & Wish Dimension Loadings Comparison') +
    theme(text = element_text(size = 8), 
          plot.title = element_text(color="black", size=14, face="bold", hjust = 0.5),
          axis.title.x = element_blank(),
          axis.title.y = element_blank())

```


## Interactive Relationship Plots
```{r}
fig <- plot_ly(as.data.frame(pv$scores), x=~RC1, y=~RC2,
             type = "scatter", mode = "markers",
             text = rownames(pv$scores),
             hoverinfo = "text")
x <- list(title = paste('PC1 (', round(res.pca_nor$eig[1,2], 2), '%)'))
y <- list(title = paste('PC2 (', round(res.pca_nor$eig[2,2], 2), '%)'))

fig <- fig %>% layout(xaxis = x, yaxis = y)
fig
```

```{r, echo=FALSE}
fig <- plot_ly(as.data.frame(pv$scores), x=~RC3, y=~RC4,
             type = "scatter", mode = "markers",
             text = rownames(pv$scores),
             hoverinfo = "text")
x <- list(title = paste('PC3 (', round(res.pca_nor$eig[3,2], 2), '%)'))
y <- list(title = paste('PC4 (', round(res.pca_nor$eig[4,2], 2), '%)'))

fig <- fig %>% layout(xaxis = x, yaxis = y)
fig
```





Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
